#pragma once

#include "esphome.h"
#include <TMC2209.h>
#include <TMCStepper.h>

namespace esphome {
namespace Cover_TMC2209 {

#define STALL_VALUE      30 // [0... 255]
#define TOFF_VALUE        4 // [1... 15]

#define EN_PIN            19 // Enable pin
#define STEP_PIN 18
#define DIR_PIN 5
#define SW_RX             16 // SoftwareSerial receive pin
#define SW_TX             17 // SoftwareSerial transmit pin
#define DIAG_PIN 2
#define INDEX_PIN 15
//#define SERIAL_PORT Serial1 // HardwareSerial port
#define DRIVER_ADDRESS 0b00 // TMC2209 Driver address according to MS1 and MS2

#define REVOLUTIONS_PER_SECOND 1
#define MSTEPS_PER_STEP 256

static const uint32_t CLOCK_FREQ= 12*1000000;
static const double MSTEP_T = (double)(1<<24)/CLOCK_FREQ;
//static const double MSTEP_T=1.39810133333333000000;
#define STEPS_PER_REVOLUTION 200
#define MSTEPS_PER_REVOLUTION (STEPS_PER_REVOLUTION * MSTEPS_PER_STEP)
#define MSTEPS_PER_SECOND (REVOLUTIONS_PER_SECOND * MSTEPS_PER_REVOLUTION * MSTEP_T)
//#define MSTEPS_PER_SECOND 71583
#define R_SENSE 0.11f // Match to your driver
                      // SilentStepStick series use 0.11
                      // UltiMachine Einsy and Archim2 boards use 0.2
                      // Panucatt BSD2660 uses 0.1
                      // Watterott TMC5160 uses 0.075

// Select your stepper driver type
//TMC2209Stepper driver(&SERIAL_PORT, R_SENSE, DRIVER_ADDRESS);
//TMC2209Stepper driver(SW_RX, SW_TX, R_SENSE, DRIVER_ADDRESS);

class Cover_TMC2209: public PollingComponent, public Cover {
    public:
        
        Cover_TMC2209(int8_t tx_pin, int8_t rx_pin, unsigned long baud_rate);
        
        void setup() override;
        void dump_config() override;
        float get_setup_priority() const override;

        //cover
        CoverTraits get_traits() override;
        void control(const CoverCall &call) override;

        void update() override;
        void loop() override;
 
    protected:
        friend class ESP32ArduinoUARTComponent;
        //sensor::Sensor *g_x = new Sensor();
    
    private:
        HardwareSerial _hw_serial;
        TMC2209 _stepper_driver;
        TMC2209Stepper driver;

        int8_t _tx_pin, _rx_pin;
        unsigned long _baud_rate;

        bool running = 0;

};

static const char *TAG = "trashcan";

Cover_TMC2209::Cover_TMC2209(int8_t tx_pin, int8_t rx_pin, unsigned long baud_rate) : 
  PollingComponent(2000),
  _hw_serial(2),
  driver(&_hw_serial, R_SENSE, DRIVER_ADDRESS),
  _tx_pin(tx_pin),
  _rx_pin(rx_pin),
  _baud_rate(baud_rate) {};
 
 
void Cover_TMC2209::setup() {
    ESP_LOGCONFIG(TAG, "Setting up TMC2209...");

    /*
    *  Initialize TMC2209 driver interface
    */

    pinMode(EN_PIN, OUTPUT);
    digitalWrite(EN_PIN, LOW);

    _hw_serial.begin(_baud_rate, SERIAL_8N1, _rx_pin, _tx_pin);

    //driver.beginSerial(115200);
    driver.begin();

  // Sets the slow decay time (off time) [1... 15]. This setting also limits
  // the maximum chopper frequency. For operation with StealthChop,
  // this parameter is not used, but it is required to enable the motor.
  // In case of operation with StealthChop only, any setting is OK.
  driver.toff(TOFF_VALUE);

  driver.rms_current(400); // mA
  driver.microsteps(MSTEPS_PER_STEP);

  // VACTUAL allows moving the motor by UART control.
  // It gives the motor velocity in +-(2^23)-1 [μsteps / t]
  // 0: Normal operation. Driver reacts to STEP input.
  // /=0: Motor moves with the velocity given by VACTUAL. 
  // Step pulses can be monitored via INDEX output.
  // The motor direction is controlled by the sign of VACTUAL.
  driver.VACTUAL(MSTEPS_PER_SECOND);

  // Comparator blank time. This time needs to safely cover the switching
  // event and the duration of the ringing on the sense resistor. For most
  // applications, a setting of 16 or 24 is good. For highly capacitive
  // loads, a setting of 32 or 40 will be required.
  driver.blank_time(24);

  // Lower threshold velocity for switching on smart energy CoolStep and StallGuard to DIAG output
  driver.TCOOLTHRS(0xFFFFF); // 20bit max
  
  // CoolStep lower threshold [0... 15].
  // If SG_RESULT goes below (semin+1)*32, CoolStep increases the current to both coils.
  // 0: disable CoolStep
  driver.semin(5);

  // CoolStep upper threshold [0... 15].
  // If SG_RESULT is sampled equal to or (semin + semax +1)*32 enough times (see sedn),
  // CoolStep decreases the current to both coils.
  driver.semax(2);

  // Sets the number of StallGuard2 readings above the upper threshold necessary
  // for each current decrement of the motor current.
  driver.sedn(0b01);

  // StallGuard4 threshold [0... 255] level for stall detection. It compensates for
  // motor specific characteristics and controls sensitivity. A higher value gives a higher
  // sensitivity. A higher value makes StallGuard4 more sensitive and requires less torque to
  // indicate a stall. The DOUBLE of this value is compared to SG_RESULT.
  // The stall output becomes active if SG_RESULT fall below this value.
  driver.SGTHRS(STALL_VALUE);

delay(1000);
running = true;
//driver.VACTUAL(1000);
//driver.ihold(32);

    // ESP_LOGCONFIG(TAG, "Testing connection...");
    // uint8_t result = driver.test_connection();

    // if (result) {
    //     ESP_LOGCONFIG(TAG, "failed!");
    //     ESP_LOGCONFIG(TAG, "Likely cause: ");

    //     switch(result) {
    //         case 1: ESP_LOGCONFIG(TAG, "loose connection"); break;
    //         case 2: ESP_LOGCONFIG(TAG, "no power"); break;
    //     }

    //     ESP_LOGCONFIG(TAG, "Fix the problem and reset board.");
        
    //     return;
    // }

    // ESP_LOGCONFIG(TAG, "OK");

    
    // _stepper_driver.setup( _hw_serial, TMC2209::SERIAL_ADDRESS_0);

    // _stepper_driver.enableAutomaticCurrentScaling();

    
    ESP_LOGCONFIG(TAG, "Setting up TMC2209 done");
}

void Cover_TMC2209::dump_config() {
    ESP_LOGCONFIG(TAG, "TMC2209:");
    ESP_LOGCONFIG(TAG, "GCONF: %X index_otpw: %d index_step: %d",driver.GCONF(), driver.index_otpw(), driver.index_step());
    ESP_LOGCONFIG(TAG, "VMSTEP_T:%f ACTUAL: %d",MSTEP_T, driver.VACTUAL());

    // if (_stepper_driver.communicating())
    // {
    //     ESP_LOGCONFIG(TAG, "Communicating with stepper driver!");
    // }
    // else
    // {
    //     ESP_LOGCONFIG (TAG, "Not communicating with stepper driver!");
    //     return;
    // }
    LOG_UPDATE_INTERVAL(this);
  
    //LOG_SENSOR(" ", "X", this->g_x);
}

float Cover_TMC2209::get_setup_priority() const { return setup_priority::DATA; }


CoverTraits Cover_TMC2209::get_traits() {
    auto traits = CoverTraits();
    traits.set_is_assumed_state(false);
    traits.set_supports_position(true);
    traits.set_supports_tilt(false);
    return traits;
    }

void Cover_TMC2209::control(const CoverCall &call) {
    // This will be called every time the user requests a state change.
    if (call.get_position().has_value()) {
        float pos = *call.get_position();
        // Write pos (range 0-1) to cover
        // ...

        // Publish new state
        this->position = pos;
        this->publish_state();
    }
    if (call.get_stop()) {
        // User requested cover stop
    }
}

void Cover_TMC2209::loop() {
    if (running) {
        auto result = driver.SG_RESULT();
        if (result < 100) {
            ESP_LOGD(TAG, "STOPPING!!!! SG_RESULT = %d", result);
            driver.VACTUAL(0);
            driver.ihold(0);
            driver.freewheel(1);
            running = false;
            this->set_timeout(10*1000, [this]() {
                driver.VACTUAL(MSTEPS_PER_SECOND);
                delay(100);
                running=true;
            });
        }
    }
}

void Cover_TMC2209::update() {

    ESP_LOGD(TAG, "SG_RESULT = %d", driver.SG_RESULT());
    
 
    this->set_timeout(50, [this]() {

        // TBD: read sensor values
        return;

        if (_stepper_driver.communicating())
        {
            ESP_LOGD(TAG, "Communicating with stepper driver!");
            _stepper_driver.enableAutomaticCurrentScaling();
        }
        else
        {
            ESP_LOGD (TAG, "Not communicating with stepper driver!");
            return;
        }

        TMC2209::Status status = _stepper_driver.getStatus();
        ESP_LOGD(TAG, "status.current_scaling = %d", status.current_scaling);
        ESP_LOGD(TAG, "status.stealth_mode = %d", status.stealth_mode);
        ESP_LOGD(TAG, "status.standstill = %d", status.standstill);
        //   Serial << "status.over_temperature_warning = " << status.over_temperature_warning << "\n";
        //   Serial << "status.over_temperature_shutdown = " << status.over_temperature_shutdown << "\n";
        //   Serial << "status.short_to_ground_a = " << status.short_to_ground_a << "\n";
        //   Serial << "status.short_to_ground_b = " << status.short_to_ground_b << "\n";
        //   Serial << "status.low_side_short_a = " << status.low_side_short_a << "\n";
        //   Serial << "status.low_side_short_b = " << status.low_side_short_b << "\n";
        //   Serial << "status.open_load_a = " << status.open_load_a << "\n";
        //   Serial << "status.open_load_b = " << status.open_load_b << "\n";
        //   Serial << "status.over_temperature_120c = " << status.over_temperature_120c << "\n";
        //   Serial << "status.over_temperature_143c = " << status.over_temperature_143c << "\n";
        //   Serial << "status.over_temperature_150c = " << status.over_temperature_150c << "\n";
        //   Serial << "status.over_temperature_157c = " << status.over_temperature_157c << "\n";
        //   Serial << "status.current_scaling = " << status.current_scaling << "\n";
        //   Serial << "status.stealth_mode = " << status.stealth_mode << "\n";
        //   Serial << "status.standstill = " << status.standstill << "\n";
        //   Serial << "\n";

        TMC2209::Settings settings = _stepper_driver.getSettings();
        ESP_LOGD(TAG, "settings.microsteps_per_step = %d", settings.microsteps_per_step);
        ESP_LOGD(TAG, "settings.zero_hold_current_mode = %d", settings.zero_hold_current_mode);
        ESP_LOGD(TAG, "settings.irun = %d", settings.irun);
        ESP_LOGD(TAG, "settings.ihold = %d", settings.ihold);
        ESP_LOGD(TAG, "settings.iholddelay = %d", settings.iholddelay);
        ESP_LOGD(TAG, "settings.automatic_current_scaling_enabled = %d", settings.automatic_current_scaling_enabled);
        Serial << "settings.microsteps_per_step = " << settings.microsteps_per_step << "\n";
        Serial << "settings.inverse_motor_direction_enabled = " << settings.inverse_motor_direction_enabled << "\n";
        Serial << "settings.spread_cycle_enabled = " << settings.spread_cycle_enabled << "\n";
        Serial << "settings.zero_hold_current_mode = ";
        switch (settings.zero_hold_current_mode)
        {
            case TMC2209::NORMAL:
            Serial<< "normal\n";
            break;
            case TMC2209::FREEWHEELING:
            Serial<< "freewheeling\n";
            break;
            case TMC2209::STRONG_BRAKING:
            Serial<< "strong_braking\n";
            break;
            case TMC2209::BRAKING:
            Serial<< "braking\n";
            break;
        }
        // Serial << "settings.irun = " << settings.irun << "\n";
        // Serial << "settings.ihold = " << settings.ihold << "\n";
        // Serial << "settings.iholddelay = " << settings.iholddelay << "\n";
        // Serial << "settings.automatic_current_scaling_enabled = " << settings.automatic_current_scaling_enabled << "\n";
        // Serial << "settings.pwm_offset = " << settings.pwm_offset << "\n";
        // Serial << "settings.pwm_gradient = " << settings.pwm_gradient << "\n";
        // Serial << "\n";


        //ESP_LOGD(TAG, "Got temperature from %#04x: %.2f °C", address_, temperature_degC);
        //this->temperature->publish_state(temperature_degC);
    });
}

} // My namespace

} //esphome namespace
